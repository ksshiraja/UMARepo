#ifndef UMA_NAVIGATION_PATH_PLANNER_H
#define UMA_NAVIGATION_PATH_PLANNER_H

#include <ros/ros.h>
#include <std_msgs/String.h>
#include <geometry_msgs/Polygon.h>
#include <geometry_msgs/Pose.h>
#include <geometry_msgs/PoseArray.h>
#include <nav_msgs/Odometry.h>
#include <tf/transform_listener.h>
#include <tf2/LinearMath/Matrix3x3.h>
#include <tf2_geometry_msgs/tf2_geometry_msgs.h>

#include <lib/errors/errors.h>
#include <uma_navigation/planner_input.h>
#include <uma_navigation/costmap_handler.h>
#include <uma_navigation/path.h>

#include <atomic>
#include <mutex>
#include <string>
#include <utility>
#include <vector>

#include <boost/thread/barrier.hpp>

// for testing
#include <gtest/gtest_prod.h>

// custom exception to be used by the planner
class PathPlannerException : public uma::UMAException
{
public:
    explicit PathPlannerException(const std::string &msg):
        uma::UMAException(msg)
    {}
};

// handles running an iteration of the path planner
// an iteration creates a path from the boat to a given target from task planning
class PathPlanner
{
public:
    explicit PathPlanner(ros::NodeHandle *nh, bool debug = false, bool init_costmap = true);
    /*
    * Set target for which we need to create a path to
    * @param target - target by task planner
    */
    void setTarget(const Target &t);

    const std::vector<Coordinate<double> >* getSplinePath();

    /*
    * Run a spin of the planner, that is:
    * given a target from task planning, try to generate a (spline) path that leads there.
    */
    std::pair<bool, bool> run();

    /*
    * Check if spline path isn't blocked by obstacles
    */
    bool isSplinePathValid();

    /*
    * Get target for which we need to create a path to
    * @param target - target by task planner
    */
    Target getTarget();

private:
    /*
    * Called when new location is received from the subscriber node.
    * Save the the boats positions, velocity, and oritentation
    * @param msg - odometry message sent from "odometry/filtered"
    */
    void localization_cbk(const nav_msgs::OdometryConstPtr &);

    /*
    * Retrieves the current challenge published by the task planner
    * @param msg - message sent from "/current_challenge"
    */
    void current_challenge_cbk(const std_msgs::String::ConstPtr &);

     /*
    * Publishes path to "path_waypoints" for debugging purposes
    * @param begin - Iterator to first element of path
    * @param end - Iterator to past last element of path
    */
    template <class Iterator>
    void publishPath(Iterator begin, Iterator end)
    {
        geometry_msgs::PoseArray poseArray;
        for (; begin != end; ++begin)
        {
            geometry_msgs::Pose pose;
            pose.position.x = begin->x;
            pose.position.y = begin->y;
            pose.position.z = 0;
            poseArray.poses.push_back(pose);
        }
        poseArray.header.frame_id = "map";
        path_publisher_.publish(poseArray);
    }

    ros::NodeHandle *node_handle_;  // pointer to current node handle
    tf::TransformListener tf_;
    CostmapHandler costmap_handler_;
    ros::Subscriber localization_subscriber_;  // subscriber to boat location
    ros::Subscriber current_challenge_subscriber_;  // subscriber to current task
    ros::Publisher path_publisher_;  // publish path in debug mode
    std::string current_challenge_;

    std::mutex input_mutex_;
    PlannerInput input_;  // current input into planner
    Path path_;  // path generated by planner

    int num_consecutive_invalid_paths_ = 0;

    bool location_received_;
    bool debug_;
};

#endif  // UMA_NAVIGATION_PATH_PLANNER_H
