# The Path Planner
## Purpose
The path planner's purpose is to take in targets from task planning, create a path to that destination that avaoids obstacles, and send this path to controls. The path should be as short as possible while still being smooth. We use costmaps generated by CV and boat odometry to generate the path.

## How to Run
1) Enter docker in the terminal
2) Run "tmux"
3) Build the repo with "build.py" if not already built.
4) Run "roscore" in a tmux window
5) Run "rosrun uma_navigation path_planner -d" to run the main path planner (running "roslaunch path_planner.launch" from the "uma_navigation/launch" folder is another way of running the path planner in debug mode).
6) Run "rosrun uma_navigation <executable>" to run one of the test executables listed below.
7) The output path can be visualized by running "rosrun rviz rviz" in a new tmux window. Click the "add" button, "by topic", then "/path_waypoints". 

### Executables
The build system will create a few executables.
- path_planner - This is what will run the main path planner. There are a few flags that you can run it with. The -d flag runs it in debug mode (the planner will publish the paths generated to the path_waypoints channel). The controls_topic flag sets which channel the planner will listen to for waypoints. If not set, the planner will use "/navigation/path" by default. The launch file for the path planner will run the planner with the default controls channel and will run it in debug mode.
- path_planner_system_test - This tests the path planning system as a whole. Main specifies a waypoint goal, a path (or paths) is created by the planner, which is sent to a simplified, simulated controls. This is defined in the ControlsActionServer class. Instead of following the path, controls just continually moves .1 units in the x and y directios closer to the goal in a loop. 
- path_planner_stress_test - This stress is the same setup as the system test, except it contains a loop that sends many goals sequence with random coordinates.

## Functionalities
Here is a list of the planner's functionalities as well as relevant files and classes:
### Interfaces with the Task Planner
It gets the target waypoint from the task planner. It also gives feedback (last reached waypoint) to the task planner as the path is being travelled. It also handles task cancellations, in which case everything about the current path (generation, sending to controls, etc) is cancelled.
Relevant files, classes, and functions:
- task_server.h
  - TaskActionServer - Interface with task planner, using the SimpleActionServer from the actionlib library (https://docs.ros.org/diamondback/api/actionlib/html/classactionlib_1_1SimpleActionServer.html). The server recieves goals over the channel "/path_planning". These goals can also be canceled/preempted by the task planner. When a goal is completed, this file sends a result message back to the task planner
- Waypoint.action
  - This file defines the mesages sent between the task planner and the path planner. These are goals sent to path planner or results/feedback sent to    the task planner (http://wiki.ros.org/actionlib)
- planner.cpp
  - PlannerHandler - Initializes the TaskActionServer class and contains the functions called by the TaskActionServer in response to a directive from the Task Planner. These are "run_planner" (for when a new goal is sent), and "stop_planner" (for when a cancel request is sent).

### Interfaces with Controls
It will take the path generated and send it to the controls system as an array of x coordinates and an array of y coordinates. If the boat hasn't reached the destination within 5 seconds (an arbitrary period of time), then we generate and send a new path based on the boats new position and updated costmap.The planner also has the capability to cancel the current path. This is usually done when task planner cancels the goal or when the path being travelled is no longer valid.
Relevant files, classes, and functions:
- control_client.h
  - ControlActionClient - interface with controls using the ActionClient form the actionlib library (http://docs.ros.org/diamondback/api/actionlib/html/classactionlib_1_1ActionClient.html). We use the non-simple version because we want the ability to have multiple active goals at once.
- Waypoints.action
  - This file defines the mesages sent between the path planner and controls. These are goals sent to controls or results/feedback sent back to the path planner (http://wiki.ros.org/actionlib)
- planner.cpp
  - PathHandler - threaded interface with ControlActionClient. New paths are passed into "setTargetPath()", which triggers processPath() to send the path to the ControlClient and wait for its return.
  - PlannerHandler::setPathAndCheckValid - Is passed path from "run_planner" and sends path to PathHandler. Because PathHandler is on its on thread, setPathAndCheckValid is able to monitor path validity while waiting for the control client to return.

### Maintains and Weights Costmap
It receives a costmap from lidar and reweights some of it for certain purposes. For example, to work better with the boat's movement, we weight the cells around the boat a to give more preference to forward movement. As new costmaps are received, the underlying cells are updated.
Relevant files, classes, and functions:
- costmap_handler.h and costmap_handler.cpp
  - CostmapHandler - handles receiving costmaps
- input_layer.h and input_layer.cpp
  - InputLayer - handles reweighting costmaps
- planner_layer.h and planner_layer.cpp
  - PlannerLayer - handles reweighting costmaps
- path_planner.h

### Generate Path 
When given a target, the path planner will generate a path to the target based on the costmap. If the target is outside the range of the costmap, it'll generate a path as far as possible within the current costmap bounds. Every 5 seconds (arbitrary value) a new path will be generated and sent to controls using the updated costmap until we arrive at the goal. The path is created in three steps. First, the path is generated on the costmap grid using theta*. Then for smoothness a spline is overlayed onto our theta* path. Last the spline is discritzed into an array of x and y coordinates of roughly equal distance between coordinates. It is possible theta* is not the optimal algorithm, yet of the path planning algos we compared, it seemed to be the best. Look at the wiki page for more info: https://gitlab.eecs.umich.edu/uma/UMARepo/-/wikis/Comparison-of-Path-Planning-Algorithms.
Relevant files, classes, and functions:
- path_gen.h and path_gen.cpp
  - thetaStarSearch - uses Theta* to generate the optimal path. Based on this paper (http://idm-lab.org/bib/abstracts/papers/aaai07a.pdf). Visualization (https://www.youtube.com/watch?v=mAaYVTedqPQ). Unlike, A*, theta* allows for path segments of any angle, not just straight or 90. This creates a straighter and shorter path.
- path_planner.h and path_planner.cpp
  - PathPlanner - A class responsible for grabbing updated costmap and odometry info, creating a new path, then publishing the path on "path_waypoints" for visualizing
  - PathPlanner::run - clears the previous path, gets updated costmap and odometry, calls theta*, then interpolates the spline. If the spline path is repeatedly invalid (may be an issue in "find the path"), no spline overlayed. 
- planner.cpp
  - PlannerHandler::run_planner - Has a while loop that calls "path_planner_.run()" to generate the path while the destination isn't reached.
- path.h and path.cpp
  - Path - contains a useful interface for storing and interacting with the path. Contains the functions to add/remove from the path, and to interpolate the spline.

### Monitors Path Validity
While travelling a path, the planner will constantly update and monitor the path's validity (things may drift in the way). If the path is found to be not valid, the current waypoint is cancelled and then the path is thrown out and recalculated.
- planner.cpp
  - PlannerHandler::setPathAndCheckValid - Will monitor the path's validity while waiting for the current waypoint to finish. It will cancel the current waypoint if the path ever becomes invalid.
  - PlannerHandler::run_planner - If the path planner generates and invalid path, wait 3 seconds (arbitrary number) and try again.
- path_planner.h
  - PathPlanner::run() - After overlaying the spline, it's possible the path will become invalid. In addition to creating path, this function returns if the generated path is valid. If 2 consecutive splines have been invalid, the next path generated will not have a spline overlayed ("noSplinePath()"). If this somehow is still invalid, the just send the path anyway. 
- path.h and path.cpp
  - isSplinePathValid() - Check the path's validity against a costmap. This is called by the above functions.

These are the main functions of the planner.

## Architecture
The main function that defines the executable can be found in planner.cpp. Here is a rundown of what happens when the planner is run.
### Startup
1. PlannerHandler (planner.cpp) - This class gets called in main when the path planner is run. It creates the TaskActionServer, ControlActionClient, and PathPlanner. It then waits for the task_server to recieve a goal from task_planning.
2. PathPlanner (path_planner.cpp) - Created by the PlannerHandler. This class will create the costmap handler and some callbacks for keeping the localization up to date. It waits for a costmap to be published. **If no costmap is recieved the path planner will stall**
2. TaskActionServer (task_server.h) - Once all the callbacks are registered, we wait for the task planner to send us commands.
### Target Waypoint Received
1. PlannerHandler::run_planner() - We run what we call an "iteration" of the path planner. An iteration is just what is done to reach a target. This function is has a while loop which continually creates and sends paths until we reach our destination.
2. PathHandler - The first thing done in the spin is create the PathHandler. This creates a thread that waits for a path to be created, sends it to controls once received, and then waits for controls to say we successfuly made it to our destination, or that we need to make another path. We create a thread so that we can check path validity and update the costmap while waiting to reach the waypoint and also so we can cancel waypoints if needed.
3. PathPlanner::run - This will generate a path, calling "thetaStarSearch()" and "path::InterpolateSpline()" to do so. The path may not reach the target because it is outside the costmap, so multiple runs may be needed. If the path produced is invalid, we wait three seconds and create a new path.
4. PlannerHandler::setPathAndCheckValid - Send the path to the PathHandler, which routes it to controls and monitor path validty.
   - Failure - If controls couldn't reach the path within 5 seconds or the path became invalid, we go back to step 3.
   - Success - In the case the boat made it to the destination within the specified error bounds, continue to step 5
5. PlannerHandler::run_planner() - Tell the taskServer that we've made it. Await the next destination.
### Waypoint Cancelled
1. PlannerHandler::stop - Does what we need to stop the planner's iteration
2. ControlActionClient::stop - Cancel the current waypoint and stop taking waypoints
3. PlannerHandler::run_planner - We wait for the planner iteration to stop via a barrier

## Issues and optimizations
- Finalize interface with motion modeling
- Optimize form paths are sent in - Currently we send paths as an array of x and y coordinates. Perhaps motion modeling's job would be easier if we found a way a more succinct/continuous and less discrete way of representing the path.
- Stress Test - The stress test should probably be more than just a copy of the system test with more waypoints.