#include <uma_navigation/path_planner.h>
#include <uma_navigation/planner_layer.h>
#include <uma_navigation/path_gen.h>
#include <uma_navigation/visualization.h>

#include <math.h>
#include <sstream>
#include <vector>
#include <utility>
#include <iostream>

using std::vector;
using std::make_pair;
using std::stringstream;
using std::endl;

using Point = geometry_msgs::Point32;
using Costmap = costmap_2d::Costmap2D;

/*
 * @param nh - node handle of )running planner
 * @param debug - sets debug mode, meaning the planner will publish the path it creates
 * @param init_costmap - whether to initialize the costmap handler since it'll hang until data is received
 */
PathPlanner::PathPlanner(ros::NodeHandle *nh, bool debug, bool init_costmap):
    node_handle_(nh),
    tf_(),
    costmap_handler_(nh, &tf_, debug),
    localization_subscriber_(nh->subscribe<nav_msgs::Odometry>("odometry/filtered", 2,
                &PathPlanner::localization_cbk, this)),
    current_challenge_subscriber_(nh->subscribe<std_msgs::String>("/current_challenge", 1,
                &PathPlanner::current_challenge_cbk, this)),
    path_(costmap_handler_.getCostmap()->getCostmap()),
    debug_(debug)
{
    if (init_costmap)
        costmap_handler_.init();
    if (debug_)
        path_publisher_ = nh->advertise<geometry_msgs::PoseArray>("path_waypoints", 1);
}

/*
 * Set target for which we need to create a path to
 * @param target - target by task planner
 */
void PathPlanner::setTarget(const Target &target)
{
    std::lock_guard<std::mutex> lock(input_mutex_);
    input_.target = target;
}

/*
 * Retrieve target for which we need to create a path to
 */
Target PathPlanner::getTarget()
{
    std::lock_guard<std::mutex> lock(input_mutex_);
    return input_.target;
}

const std::vector<Coordinate<double> >* PathPlanner::getSplinePath()
{
    return path_.getSplinePath();
}

/*
 * Run a spin of the planner, that is:
 * given a target from task planning, try to generate a (spline) path that leads there.
 */
std::pair<bool, bool> PathPlanner::run()
{
    std::lock_guard<std::mutex> input_lock(input_mutex_);
    while (!location_received_)
        return make_pair(false, false);

    // clear any previous path
    path_.clearPath();
    // update and weight costmap
    costmap_handler_.update(input_.pose);
    // calculate path
    MapCell<unsigned int> boat_cell;
    if (!costmap_handler_.getCostmap()->getCostmap()->worldToMap(input_.pose.x, input_.pose.y,
                boat_cell.x, boat_cell.y))
    {
        std::stringstream ss;
        ss << "Boat not withing costmap! Boat at world coord " << input_.pose.x << "," << input_.pose.y;
        ss << " and grid square " << boat_cell.x << "," << boat_cell.y;
        throw PathPlannerException(ss.str());
    }
    // create path
    GridCell start_cell { static_cast<int>(boat_cell.x), static_cast<int>(boat_cell.y) };
    Waypoint target = waypointFrom<Waypoint, Target>(input_.target);
    try
    {
        thetaStarSearch(&path_, costmap_handler_.getCostmap()->getCostmap(), start_cell, target);
    }
    catch (const uma::UMAException &e)
    {
        // the boat is stuck!
        ROS_ERROR("%s", e.what());
        if (num_consecutive_invalid_paths_ > 3)
        {
            // repeated failure. Create path thats just start and end point
            Waypoint point(start_cell.x, start_cell.y);
            path_.addWaypoint(point);
            path_.addWaypoint(target);
            ROS_INFO("Path planner is repeatedly stuck and can't create a path. Creating a path straight to destination"); //NOLINT
        }
        else
        {
            // trying again after 3 sec wait
            num_consecutive_invalid_paths_++;
            return make_pair(false, false);
        }
    }

    // take the path of waypoints generated by theta* and create path
    bool ignore_obstacles = false;
    if (num_consecutive_invalid_paths_ < 2)
    {
        // add the spline if we haven't been having issues generating a valid path
        ROS_INFO("[PATH PLANNER] num_consecutive_invalid_paths_: %d", num_consecutive_invalid_paths_);
        ROS_INFO("[PATH PLANNER] Interpolating Spline");
        path_.interpolateSpline();
    }
    else
    {
        // if the path created keeps on being invalid after the spline is added, ditch the spline
        ROS_INFO("[PATH PLANNER] num_consecutive_invalid_paths_: %d", num_consecutive_invalid_paths_);
        ROS_INFO("[PATH PLANNER] Not Spline Path");
        path_.noSplinePath();
    }

    if (debug_)
    {
        publishPath(path_.getSplinePath()->begin(), path_.getSplinePath()->end());
    }
    // validate path
    bool spline_valid = isSplinePathValid();
    if (!spline_valid)
    {
        if (num_consecutive_invalid_paths_ > 3)
        {
            // if even the noSpline path is somehow invalid, just follow the path anyway
            ignore_obstacles = true;
            spline_valid = true;
            ROS_INFO("Path Planner can't generate a valid path after repeated tries and waiting. Following the path, regardless of obstacles"); //NOLINT
            num_consecutive_invalid_paths_ = 0;
        }
        else
            num_consecutive_invalid_paths_++;
    }
    else
    {
        num_consecutive_invalid_paths_ = 0;
    }
    return make_pair(spline_valid, ignore_obstacles);
}

/*
 * Check if spline path isn't blocked by obstacles
 */
bool PathPlanner::isSplinePathValid()
{
    return path_.isSplinePathValid();
}

/*
 * Called when new location is received from the subscriber node.
 * Save the the boats positions, velocity, and oritentation
 * @param msg - odometry message sent from "odometry/filtered"
 */

void PathPlanner::localization_cbk(const nav_msgs::OdometryConstPtr &msg)
{
    // get 2d orientation angle
    tf2::Quaternion q;
    tf2::fromMsg(msg->pose.pose.orientation, q);

    // yaw contains 2d orientation angle as it is a rotation about z axis
    double roll, pitch, yaw;
    tf2::Matrix3x3(q).getRPY(roll, pitch, yaw);

    // set orientation in planner input
    std::lock_guard<std::mutex> lock(input_mutex_);
    input_.pose.x = msg->pose.pose.position.x;
    input_.pose.y = msg->pose.pose.position.y;
    input_.pose.xVel = msg->twist.twist.linear.x;
    input_.pose.yVel = msg->twist.twist.linear.y;
    input_.pose.orientationAngle = yaw;

    location_received_ = true;
}
/*
 * Retrieves the current challenge published by the task planner
 * @param msg - message sent from "/current_challenge"
 */
void PathPlanner::current_challenge_cbk(const std_msgs::String::ConstPtr &msg)
{
    std::lock_guard<std::mutex> lock(input_mutex_);
    current_challenge_ = msg->data;
}
